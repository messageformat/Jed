<!doctype html>
<!--[if lt IE 7]> <html class="ie6 oldie" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="ie7 oldie" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="ie8 oldie" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html lang="en"> <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <title>Jed | Gettext Style i18n for Modern JavaScript Apps</title>
  <meta name="description" content="Gettext Style i18n for Modern JavaScript Apps">
  <meta name="author" content="Alex Sexton">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="stylesheet" href="css/bootstrap.min.css">
  <link rel="stylesheet" href="css/style.css">
</head>
<body>

  <div class="container">
  <h1>Jed</h1>
  <h3>Gettext Style i18n for Modern JavaScript Apps</h3>
  <img src="img/jedhead.png" id="jedhead" />
  <a id="fork" href="https://github.com/SlexAxton/Jed"><img src="http://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" /></a>
<pre id="headerCode"><code>var i18n = new Jed({ locale_data: { ... } });

// Use the chainable API

i18n.translate("There is one translation.")
    .onDomain("messages")
    .withContext("male")
    .ifPlural( num, "There are %d translations." )
    .fetch( num );

// Or kick it old school

var out = i18n.dnpgettext(
  "messages",
  "male",
  "There is one translation.",
  "There are %d translations.",
  num
);

Jed.sprintf( out, num );
</code></pre>

  <h2>Gettext?</h2>

  <p>Gettext is an old translation standard. It solves a unique set of problems when dealing with things like
  pluralization and positional interpolation. There are implementations of gettext in nearly every language
  (including javascript). I wasn't happy with the quality, safety, or speed of other javascript implementations
  and thus Jed was born. You can read more about Gettext here: <a href="http://www.gnu.org/software/gettext/">gnu.org/software/gettext/</a></p>

  <h2>Safety and Speed</h2>

  <p>Jed parses <code>plural forms</code> using a grammar instead of running <code>eval</code>. This results
  in both safer and faster plural-form function generations. The jison grammar that was used to generate the
  parser is included in the source.</p>

  <p>You can find a fairly comprehensive list of plural forms here:
  <a href="http://translate.sourceforge.net/wiki/l10n/pluralforms">translate.sourceforge.net/wiki/l10n/pluralforms</a>
  </p>

  <h2>Sane API Wrappers</h2>

  <p>Sometimes using <code>gettext</code> directly is fine, but knowing which gettext function to call at
  runtime can often be cumbersome. Since JavaScript supports things like chaining and function overloading,
  we can wrap the original API with one that feels a bit more modern.</p>

  <h2>Jed API</h2>

  <p>The core available functions on an instantiated Jed object are:</p>
  <ul>
    <li><strong class="mono">translate( key )</strong> - Sets the key to translate (often english).</li>
    <li><strong class="mono">onDomain( domain )</strong> - Sets the domain to use in the locale_data.</li>
    <li><strong class="mono">withContext( context )</strong> - Specifies the context prefix for key lookup.</li>
    <li><strong class="mono">ifPlural( num, plural_key )</strong> - Specifies the plural translation path and plural value.</li>
    <li><strong class="mono">fetch( sprintf, style, args )</strong> - the values to interpolate into the response.</li>
  </ul>

  <p>Jed also exposes all the standard Gettext functions on an instance. Those behave according to spec and are
  detailed further down in the document. Here's how you use these "more-friendly-than-direct-gettext"
  functions:</p>

<pre><code>
// Create a new instance
var i18n = new Jed({

  // You can choose to set the domain at instantiation time
  // If you don't, then "messages" will be used by default
  "domain" : "the_domain",

  // This callback is called when a key is missing
  "missing_key_callback" : function(key) {
    // Do something with the missing key
    // e.g. send key to web service or
    console.error(key)
  },

  // This is the translation data, which is often generated by
  // a po2json converter. You would ideally have one per locale
  // and only pull in the locale_data that you need.
  "locale_data" : {

    // This is the domain key
    "the_domain" : {

      // The empty string key is used as the configuration
      // block for each domain
      "" : {
        // Domain name
        "domain" : "the_domain",

        // Language code
        "lang" : "en",

        // Plural form function for language
        "plural_forms" : "nplurals=2; plural=(n != 1);"
      },

      // Other keys in a domain contain arrays as values
      // that map to the translations for that key.
      // Gettext suggests that you use english as your keys
      // in case the key isn't found, and it can just pass
      // the value directly through.
      "a key" : [ "the translation", "the plural translations", ... ],

      // The plural form string is converted into a function
      // and the value that's passed into the gettext call
      // is passed into the plural form function. It's result
      // (plus 1) is the index that the translation comes from.

      // We're using sprintf interpolation on our keys so we can
      // then sub in the _actual_ values into the result.
      "%d key" : [ "%d key", "%d keys" ],

      // Contexts are keys that are just prefixed with a context string
      // with a unicode \u0004 as the delimiter.
      // You can use it for anything. Usually it's just for being content aware
      // in some way (e.g. male vs. female, product vs. category)
      "context\u0004%d key": [ "context %d key", "context %d keys" ]
    }
  }
});</code></pre>

  <p>Now that you have an instance that's attached to a set of locale data, and often a default domain, you'll
  want to pull out translations</p>

<pre><code>// The translate function is chained, and doesn't
// end until you call 'fetch'
i18n.translate('a key').fetch();
> "the translation"

// Most apps will only require a single Jed instance, but
// occasionally you may need more. You can use the same
// instance to make as many queries as you want.

// Keys that don't exist are passed through directly, so in the case of missing
// translations, you still get the default language.

var n = 5;
i18n.translate("%d key doesnt exist").ifPlural( n, "%d keys dont exist" ).fetch();
> "%d keys dont exist"

// You can pass in sprintf arguments to fetch to do value interpolation

i18n.translate("%d key doesnt exist").ifPlural( n, "%d keys dont exist" ).fetch( n );
> "5 keys dont exist"

// It's important that you still give the default language plural
// version in the `ifPlural` call for cases when the key doesn't
// exist, however, normally, the values in the translation object
// are the returned values.
i18n.translate("%d key").ifPlural( n, "not used, but still important" ).fetch( n );
> "5 keys"

// We can specify a context in our chain
i18n.translate("%d key").withContext("context").ifPlural( n, "default %d keys" ).fetch( n );
> "context 5 keys"

// We can also change/set our domain if we have more than one
i18n.translate("a key").onDomain("other_domain").fetch();
> "Whatever the value was on that domain ;)"

// We can use the sprintf positional capabilities in our replacement
// This is a super contrived example of that:
i18n.translate("I like the %1$s %2$s.").fetch( "red", "shirt" );
> "I like the red shirt."

// Then in our spanish language file, we'd have the key:
{ ...
"I like the %1$s %2$s." : [ "Me gusta la %2$s %1$s.", ... ]
... }

// <strong>Notice the reverse numbering</strong>, so our result on that locale_data would be:
i18n.translate("I like the %1$s %2$s.").fetch( "roja", "camisa" );
> "Me gusta la camisa roja."

</code></pre>

  <h2>Installation</h2>

  <h3>Node</h3>

<pre><code>npm install jed</code></pre>

  <p>Then in your app:</p>

<pre><code>var Jed = require('jed');</code></pre>

  <h3>Webpage ( global )</h3>

<pre><code>&lt;script src="jed.js">&lt;/script>
&lt;script>
var i18n = new Jed({
  // Generally output by a .po file conversion
  locale_data : {
    "messages" : {
      "" : {
        "domain" : "messages",
        "lang"   : "en",
        "plural_forms" : "nplurals=2; plural=(n != 1);"
      },
      "some key" : [ "some value"]
    }
  },
  "domain" : "messages"
});

alert( i18n.gettext( "some key" ) ); // alerts "some value"
&lt;/script></code></pre>

  <h3>AMD Module</h3>


<pre><code>require(['jed'], function ( Jed ) {
  var i18n = new Jed({
    // Generally output by a .po file conversion
    locale_data : {
      "messages" : {
        "" : {
          "domain" : "messages",
          "lang"   : "en",
          "plural_forms" : "nplurals=2; plural=(n != 1);"
        },
        "some key" : [ "some value"]
      }
    },
    "domain" : "messages"
  });

  alert( i18n.gettext( "some key" ) ); // alerts "some value"
  });
});</code></pre>

  <h2>Details</h2>

  <p>The GNU gettext stuff defines 4 modifiers for gettext</p>

  <ul>
    <li>d - <strong>Domain</strong> -
    maps to the domain property in the translation files
    <li>c - <strong>Category</strong> -
    ignored in Jed, not applicable
    <li>n - <strong>Plurals</strong> -
    handles translations based on pluralization rules for specific languages
    <li>p - <strong>Context</strong> -
    used as translation key prefixes, usually for quick modifiers of the same translation
  </ul>

  <p><small>Note :: I took the same path as `gettext.js` and just ignore any 'Category' information. The methods
    are exposed but the information is ignored. I'd recommend not using them at all, but I figured I'd be as
    API compatible with gettext.js as possible.</small></p>

  <p>These map to the properties in the translation files.<p>

  <p>At its base, Jed exposes (nearly) every combination of these four letters as functions</p>

<pre><code>gettext = function ( key )
dgettext = function ( domain, key )
dcgettext = function ( domain, key, category )
ngettext = function ( singular_key, plural_key, value )
dngettext = function ( domain, singular_ley, plural_key, value )
dcngettext = function ( domain, singular_key, plural_key, value, category )
pgettext = function ( context, key )
dpgettext = function ( domain, context, key )
npgettext = function ( context, singular_key, plural_key, value )
dnpgettext = function ( domain, context, singular_key, plural_key, value )
dcnpgettext = function ( domain, context, singular_key, plural_key, value, category )</code></pre>

  <p>In the code, every function ends up calling <code>dcnpgettext</code> since it's the most specific. It just handles
  the missing values in the correct manner.</p>

  <p>Jed intentionally made many of the same API choices as gettext.js for these lower level calls in order to offer a step
  up from gettext.js</p>

  <p>That means in order instantiate an object to call these functions, you need to create a new `Jed` instance:</p>

<pre><code>var i18n = new Jed( options );</code></pre>

  <p>Then you'll have the methods available to you. e.g. : <code>i18n.gettext( 'key' );</code></p>

  <p>The <code>options</code> object generally contains 1 or 2 keys: <code>domain</code> and <code>locale_data</code></p>

  <p>The <code>domain</code> setting is which group inside of <code>locale_data</code> that the keys will be
  looked up in.</p>

  <p>The <code>locale_data</code> is the output from your po2json converter. The tests have a few good
  examples of what these can look like if you are in need of more examples. Here's one to boot:</p>

<pre><code>var locale_data_multi = {
  "messages_3": {
    "": {
      "domain": "messages_3",
      "lang": "en",
      "plural-forms": "nplurals=2; plural=(n != 1);"
    },
    "test": ["test_1"],
    "test singular": ["test plural", "test_1 singular", "test_1 plural"],
    "context\u0004test": ["test_1 context"],
    "context\u0004test singular": ["test context plural", "test_1 context singular", "test_1 context plural"]
  },
  "messages_4": {
    "": {
      "domain": "messages_4",
      "lang": "en",
      "plural-forms": "nplurals=2; plural=(n != 1);"
    },
    "test": ["test_2"],
    "test singular": ["test plural", "test_2 singular", "test_2 plural"],
    "context\u0004test": ["test_2 context"],
    "context\u0004test singular": ["test context plural", "test_2 context singular", "test_2 context plural"]
  }
};</code></pre>

  <h2>Other Functions</h2>

  <h3>Jed.sprintf</h3>

  <p>This is the <code>sprintf</code> found at <a href="http://www.diveintojavascript.com/projects/javascript-sprintf">www.diveintojavascript.com/projects/javascript-sprintf</a>
  - Courtesy of Alexandru Marasteanu.</p>

  <p>It lives as both a 'static' method on the <code>Jed</code> function and on an individual instance. It is used for
  variable replacement after a translation happens. It supports reordering of values as well.</p>

  <p>The english translation returns: <code>"There are %1$d %2$s crayons."</code>
  <br /><br />
  Then with sprintf, we can do: <code>alert( Jed.sprintf( "I like your %1$s %2$s.", 'red', 'shirt' ) );</code>
  <br /><br />
  This alerts <code>I like your red shirt.</code>
  </p>

  <p>But in spanish it would look more like this:</p>

<pre><code>alert( Jed.sprintf( "Me gusta tu %2$s %1$s.", 'roja', 'camisa' ) );
// This alerts "Me gusta tu camisa roja."
</code></pre>

  <h2>Translation files (as json)</h2>

  <p>There are quite a few available .po to .json converters out there. Gettext .po files are standard
  output from most decent translation companies, as it's an old standard.</p>

  <p>I currently use:
  <a href="https://www.npmjs.org/package/po2json">po2json</a></p>

  <p>However, I'd like to add this functionality to a separate Jed module in a future version.</p>

  <h2>License</h2>
  <p>You may use this software under the WTFPL.</p>

  <p>You may contribute to this software under the Dojo CLA -
  <a href="http://dojofoundation.org/about/cla">http://dojofoundation.org/about/cla</a></p>

  <h2>Tests</h2>
<pre><code>npm install
make test
make test-browser
</code></pre>

  <h2>The name</h2>

  <p>The name jed.js is an homage to <a href="https://twitter.com/#!/jedschmidt">Jed Schmidt</a> - the JavaScript community member who is a japanese
  translator by day, and a "hobbyist" JavaScript programmer by night. Give your kids three character
  names and they'll probably get software named after them too.</p>

  <p>Not coincidentally, his project <a href=" https://github.com/jed/locale">locale</a> could be a good plug
  into jed.js.</p>

  <h2>Why gettext?</h2>

  <p>Internationalization is hard. Sun created gettext back in the day as a way to make things
  a little easier.</p>

  <p>Many apps that try to internationalize start out with simple key replacements.</p>

<pre><code>&lt;h1>{{i18n_helper "some_key"}}&lt;/h1></code></pre>

  <p>Then they just map each locale to a different object</p>

<pre><code>{
  en_us : {
    some_key : "This is a title."
  },
  en_ca : {
    some_key : "This is a title, eh?"
  }
}</code></pre>

  <p>That works for a little while, until you get into a situation where pluralization changes the
  structure of the sentence.</p>

  <p>Consider: <em>"I have a toaster"</em> vs. <em>"I have 3 toasters"</em></p>

  <p>Some people choose to solve this with pre/postfix data:</p>

  <pre><code>"I have the following amount of toasters: " + num_toasters</code></pre>

  <p>This is not ideal from a UX standpoint, and it doesn't work in every language, so some people
  try to do this logic themselves:</p>

<pre><code>if ( num_toasters === 1) {
  return i18n('single_toaster_key');
}
else {
  return i18n('plural_toaster_key');
}
</code></pre>

  <p>That seems to be a good solution until you consider languages like Polish and Russian that
  have _much_ more complex rulesets for pluralization than `if not 1`. Splitting the logic on each
  language hardly makes it sane or decoupled, so that method is a bust.</p>

  <h4>Gettext + sprintf solve these problems.</h4>

<pre><code>alert( sprintf( ngettext('I have one toaster.', 'I have %1$d toasters.', num_toasters), num_toasters ) )</code></pre>

  <p>This would look up the translation for the 'I have one toaster' string, evaluate, the `num_toasters` value
  against it's `plural_forms` rule, choose the appropriate sprintf-able string to return, then the sprintf will
  sub in the correct data, and output a happy translated string. Since sprintf can handle argument reordering
  words can be mixed around based on languages own rules.</p>

  <h2>Bonus</h2>

  <p>You should use gettext because it works, but also, most major translation support the delivery of `.po`
  files which are the input to gettext based apps. Different languages vary in their implementations, slightly,
  but for the most part, these `.po` files can be converted and used nearly untouched.</p>

  <h2>References</h2>
    <ul>
      <li>Mozilla has a good write up on gettext here: <a href="https://developer.mozilla.org/en/gettext">developer.mozilla.org/en/gettext</a></li>
      <li>The GNU spec is pretty big, but here: <a href="http://www.gnu.org/savannah-checkouts/gnu/gettext/manual/html_node/gettext.html">www.gnu.org/savannah-checkouts/gnu/...</a></li>
    </ul>

  <h2>Credits</h2>
  <p>Jed is brought to you by
  <br /><br />
  <img src=https://secure.gravatar.com/avatar/7ea369b9b67a85f638af2e0f5d708d2d?s=80>
  <br />
  <strong>Alex Sexton</strong><br />
  <a href=//yepnopejs.com>yepnope.js</a> / <a href=//modernizr.com>Modernizr</a> / <a href=//bazaarvoice.com>Bazaarvoice</a>
  <br><a href=//twitter.com/slexaxton>@slexaxton</a>
  </p>

  <br />
  <p>Jed would not be possible with out the prior work of <br />
  <br />
  <strong>Joshua I. Miller (his work on gettext.js) </strong>
  <br />
  and <strong>Alexandru Marasteanu (his sprintf implementation)</strong>.</p>
  </div>

  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
  <script>
    $(function(){
(function (hijs) {
//
// hijs - JavaScript Syntax Highlighter
//
// Copyright (c) 2010 Alexis Sellier
//

// All elements which match this will be syntax highlighted.
var selector = hijs || 'code';

var keywords = ('var function if else for while break switch case do new null in with void '
               +'continue delete return this true false throw catch typeof with instanceof').split(' '),
    special  = ('eval window document undefined NaN Infinity parseInt parseFloat '
               +'encodeURI decodeURI encodeURIComponent decodeURIComponent').split(' ');

// Syntax definition
// The key becomes the class name of the <span>
// around the matched block of code.
var syntax = [
  ['comment', /(\/\*(?:[^*\n]|\*+[^\/*])*\*+\/)/g],
  ['comment', /(\/\/[^\n]*)/g],
  ['string' , /("(?:(?!")[^\\\n]|\\.)*"|'(?:(?!')[^\\\n]|\\.)*')/g],
  ['regexp' , /(\/.+\/[mgi]*)(?!\s*\w)/g],
  ['class'  , /\b([A-Z][a-zA-Z]+)\b/g],
  ['number' , /\b([0-9]+(?:\.[0-9]+)?)\b/g],
  ['keyword', new(RegExp)('\\b(' + keywords.join('|') + ')\\b', 'g')],
  ['special', new(RegExp)('\\b(' + special.join('|') + ')\\b', 'g')]
];
var nodes, table = {};

if (/^[a-z]+$/.test(selector)) {
    nodes = document.getElementsByTagName(selector);
} else if (/^\.[\w-]+$/.test(selector)) {
    nodes = document.getElementsByClassName(selector.slice(1));
} else if (document.querySelectorAll) {
    nodes = document.querySelectorAll(selector);
} else {
    nodes = [];
}

for (var i = 0, children; i < nodes.length; i++) {
    children = nodes[i].childNodes;

    for (var j = 0, str; j < children.length; j++) {
        code = children[j];

        if (code.length >= 0) { // It's a text node
            // Don't highlight command-line snippets
            if (! /^\$\s/.test(code.nodeValue.trim())) {
                syntax.forEach(function (s) {
                    var k = s[0], v = s[1];
                    code.nodeValue = code.nodeValue.replace(v, function (_, m) {
                        return '\u00ab' + encode(k) + '\u00b7'
                                        + encode(m) +
                               '\u00b7' + encode(k) + '\u00bb';
                    });
                });
            }
        }
    }
}
for (var i = 0; i < nodes.length; i++) {
    nodes[i].innerHTML =
        nodes[i].innerHTML.replace(/\u00ab(.+?)\u00b7(.+?)\u00b7\1\u00bb/g, function (_, name, value) {
            value = value.replace(/\u00ab[^\u00b7]+\u00b7/g, '').replace(/\u00b7[^\u00bb]+\u00bb/g, '');
            return '<span class="' + decode(name) + '">' + escape(decode(value)) + '</span>';
    });
}

function escape(str) {
    return str.replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

// Encode ASCII characters to, and from Braille
function encode (str, encoded) {
    table[encoded = str.split('').map(function (s) {
        if (s.charCodeAt(0) > 127) { return s }
        return String.fromCharCode(s.charCodeAt(0) + 0x2800);
    }).join('')] = str;
    return encoded;
}
function decode (str) {
    if (str in table) {
        return table[str];
    } else {
        return str.trim().split('').map(function (s) {
            if (s.charCodeAt(0) - 0x2800 > 127) { return s }
            return String.fromCharCode(s.charCodeAt(0) - 0x2800);
        }).join('');
    }
}

})(window.hijs);
});
  </script>
  <script>
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-28490866-1']);
    _gaq.push(['_setDomainName', 'github.com']);
    _gaq.push(['_trackPageview']);
    (function() {
     var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
     ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
     var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
     })();
   </script>
</body>
</html>
